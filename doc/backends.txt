Drawing Backends
================

Drawing backends provide means to draw into computer screen or into a window
inside of running operating system. Instead of having one unified
initialization interface each backend has it's specific function and semantics
but once backend is initialized the backend structure provides unified API for 
controlling the drawing.

So far there are backends for Linux mmaped frame-buffer, libSDL and X11.

For example usage see backend link:example_backend.html[example].

Initialization functions
------------------------

Linux Framebuffer
~~~~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
GP_Backend *GP_BackendLinuxFBInit(const char *path, int flag);
-------------------------------------------------------------------------------

Initializes mmaped frame-buffer backend. The path is path to the frame-buffer
device i.e. '/dev/fbX'. This backend is not buffered, everything you draw
appears on the screen right away (an switch may be added for that purpose).

If flag is set console KBD driver is used to feed keystrokes into the event
queue, otherwise no events are generated and you are expected to initialize
input event driver in order to get keystrokes and/or pointer events.


SDL
~~~

[source,c]
-------------------------------------------------------------------------------
enum GP_BackendSDLFlags {
        GP_SDL_FULLSCREEN = 0x01,
        GP_SDL_RESIZABLE  = 0x02,
};

GP_Backend *GP_BackendSDLInit(GP_Size w, GP_Size h,
                              uint8_t bpp, uint8_t flags,
                              const char *caption);
-------------------------------------------------------------------------------

Initialize 'SDL' as an backend driver. The backend is thread safe as all the
operations are guarded by locks.

You can't initialize more than one backend at a time, which is inherited 'SDL'
limitation. If you call the initialization for a second time, you will get a
pointer to already running backend.

This driver feeds input events into global input event queue (see input docs
for details). 

If w, h and/or bpp are zero SDL tries to do a guess, most of the time wrong
for w and h though.

The caption is window caption.

And finally flags may change the SDL to go to full-screen mode or make the
window resizable.


[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_SDL_Context.h>

int GP_ContextFromSurface(GP_Context *c, const SDL_Surface *surf);
-------------------------------------------------------------------------------

This function allows you to mix 'SDL' and 'GFXprim' code. The functions
initializes the context from 'SDL' surface using the pixel buffer from surface
as pixel buffer for the context.

Function returns zero on succes and non-zero on failure (There is no GFXprim
pixel type to match given surface).

For example usage see 'SDL' glue link:example_SDL_glue.html[example].

X Server
~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <backends/GP_X11.h>

enum GP_BackendX11Flags {
	/* When set, w and h is ignored and root window is used */
	GP_X11_USE_ROOT_WIN = 0x01,
	
	/* Create new borderless window above the root window */
	GP_X11_CREATE_ROOT_WIN = 0x02,

	/* Start fullscreen */
	GP_X11_FULLSCREEN = 0x04,

	/* Do not use MIT SHM even if available */
	GP_X11_DISABLE_SHM = 0x08,
};

GP_Backend *GP_BackendX11Init(const char *display, int x, int y,
                              unsigned int w, unsigned int h,
                              const char *caption,
                              enum GP_BackendX11Flags flags);
-------------------------------------------------------------------------------

Returns pointer to initialized X11 backend or in case of failure 'NULL'.

When display is 'NULL' default display is used (which is what you want most of the
time).

This backend feeds key events into global input queue.

TODO: X11 backend will be changed to support more windows at a time.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <backends/GP_X11.h>

/*
 * Returns non-zero if backend is X11 backend
 */
int GP_BackendIsX11(GP_Backend *self);

/*
 * Changes full screen mode.
 * 
 * 0 = off
 * 1 = on
 * 2 = toggle
 */
void GP_BackendX11RequestFullscreen(GP_Backend *self, int mode);
-------------------------------------------------------------------------------

The 'GP_BackendIsX11' functions allows us to detect if we are running using
X11 backend.

The 'GP_BackendX11RequestFullscreen' can toggle fullscreen mode at runtime.

Overall init function
~~~~~~~~~~~~~~~~~~~~~

Although there is no unified backend initialization, there is something close to
it.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>

GP_Backend *GP_BackendInit(const char *params, const char *caption, FILE *help);
-------------------------------------------------------------------------------

This function takes a params string as an parameter which is used for
determining backend-dependent parameters. The format is
'backend_name:backend_parameters' where backend parameters may be window size
(either 'WxH' or 'FS' in case of SDL backend). The caption is window caption
(which is ignored in some of the cases) and the 'FILE' is file, where an error
is printed in case of failure, you should mostly use 'stderr' for that
purpose. If params is set to 'NULL' the the call only prints help into the
passed help 'FILE'. If initialization was successful pointer to allocated and
initialized backend is returned otherwise 'NULL' is returned and some helpful
information should be printed into the passed help 'FILE'.


Drawing Backend API
~~~~~~~~~~~~~~~~~~~

The drawing backend API consist of structure with callbacks. Every backend
initialization yields pointer to this structure. Although is possible to call
these pointers directly it's not recommended and everybody should rather use
backend inline functions instead.

The backend API consist GP_Backend structure and of several functions:

[source,c]
-------------------------------------------------------------------------------
typdef struct GP_Backend {
        /*
         * Backend name.
         */
        const char *name;

        /* 
         * Pointer to context app should draw to.
         */
        GP_Context *context;

	...

	/* 
         * Connection fd. Set to -1 if not available 
         */
        int fd;
};
-------------------------------------------------------------------------------

The file descriptor 'fd' is either set to -1 (in case of SDL that shadows it)
or to a backend connection file descriptor usable for 'select()' or 'poll()'.

[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_Backend.h>
/* or */
#include <GP.h>

void GP_BackendExit(GP_Backend *backend);
-------------------------------------------------------------------------------

Calls an backend exit callback. Resets the display, keyboard, etc. state back.

WARNING: It's very important to call this functions on application exit. If you
         doesn't do so, the state of the display, resolution etc. may not be
         reset back to its original state. This includes program crashes and
         iterruptions. Also this function may not be signal-async-safe, it's
         better to set signal hanlers that calls it as this usually works and
	 not doing so may leave non-working system with black display or
	 non-responding keyboard.

[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_Backend.h>
/* or */
#include <GP.h>

GP_BackendFlip(GP_Backend *backend);
-------------------------------------------------------------------------------

Flips a screen. Updates rectangle for a buffered backends.

[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_Backend.h>
/* or */
#include <GP.h>

void GP_BackendUpdateRect(GP_Backend *backend,
                          GP_Coord x0, GP_Coord y0,
                          GP_Coord x1, GP_Coord y1);
-------------------------------------------------------------------------------

Updates particular rectangle for a buffered backends.

[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_Backend.h>
/* or */
#include <GP.h>

void GP_BackendPoll(GP_Backend *backend);
-------------------------------------------------------------------------------

Polls for backend events. For backends that do not expose file descriptor
(namely SDL) this should be called repeatedly. For other backend it may be
called either repeatedly or when data are ready on file-descriptor.


[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_Backend.h>
/* or */
#include <GP.h>

void GP_BackendWait(GP_Backend *backend);
-------------------------------------------------------------------------------

Blocks until backend event arrives.

NOTE: Events recieved by backend are not necessarily translated into the input
      events.

WARNING: Using GP_BackendWait() in multithreaded program will most likely
         cause deadlocks. As the backend data structures and connection is
	 guarded by a lock any other backend function (called from different
	 thread while GP_BackendWait() is blocking) will lock until
	 GP_BackendWait() returns (i.e. event was recieved).

[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_Backend.h>
/* or */
#include <GP.h>

int GP_BackendSetCaption(GP_Backend *backend, const char *caption)
-------------------------------------------------------------------------------

Sets backend caption. On success zero is returned. On failure (backend doesn't
support caption, operation failed) non zero is returned.

[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_Backend.h>
/* or */
#include <GP.h>

int GP_BackendResize(GP_Backend *backend, uint32_t w, uint32_t h);
-------------------------------------------------------------------------------

Resize backend, if supported. On success zero is returned and backend is
resized, otherwise (if resize failed, or is not supported) non-zero is
returned. If backend size already matches w and h, nothing is done.

Note that backend->context pointer may change upon calling this function and
at least backend->context->pixels pointer will change.

[source,c]
-------------------------------------------------------------------------------
#include <backends/GP_Backend.h>
/* or */
#include <GP.h>

int GP_BackendResizeAck(GP_Backend *self);
-------------------------------------------------------------------------------

If backend is resizeable by user interaction (for example X Window) you will
get resize event for each change of window size, however the backend context
will not be resized untill you call this function. This is usefull in
multithreaded application where one threads waits for events and others draws
into the buffer so you can stop the drawing threads before the backend context
size change.

See input link:input.html[input events] for more information.
