Linux SPI and GPIO
------------------

This is a low level interface to a GPIO and SPI under Linux. This
functionality is used by the link:backends_display.html[display backends] to
communicate to the hardware.

.Linux userspace GPIO
[source,c]
-------------------------------------------------------------------------------
enum gp_gpio_dir {
	GP_GPIO_IN = 0,
	GP_GPIO_OUT = 1,
};

struct gp_gpio {
	const uint16_t nr;
	/* enum gp_gpio_dir */
	const uint16_t dir:1;
	int fd;
};

void gp_gpio_unexport(struct gp_gpio *gpio, unsigned int gpio_cnt);

int gp_gpio_export(struct gp_gpio *gpio, unsigned int gpio_cnt);

int gp_gpio_write(struct gp_gpio *self, int val);

int gp_gpio_read(struct gp_gpio *self);
-------------------------------------------------------------------------------

Linux GPIO implements an API to atomically export an array of GPIOs.

.Example usage
[source,c]
-------------------------------------------------------------------------------
static struct gp_gpio gpio_map[] = {
	{.nr = 10, dir = GP_GPIO_OUT},
	{.nr = 12, dir = GP_GPIO_OUT},
};

...
	/* Export GPIO 10 and 12 to be usable from userspace */
	if (gp_gpio_export(gpio_map, 2)) {
		printf("Failed to export GPIOs\n");
		return 1;
	}

	/* Turn ON GPIO 10 */
	gp_gpio_write(&gpio_map[0], 1);

	...


	/* Unexport the GPIOs */
	gp_gpio_unexport(gpio_map);
...
-------------------------------------------------------------------------------

.Linux userspace SPI (spidev)
[source,c]
-------------------------------------------------------------------------------
#include <linux/spi/spidev.h>

/**
 * @brief Opens a SPI bus.
 *
 * @spi_dev A SPI device dev path, e.g. /dev/spidev0.0
 * @mode A SPI mode, SPI_* constants in the linux/spi/spidev.h
 * @speed A SPI speed in Hz.
 *
 * @return A file descriptor or -1 in a case of a failure.
 */
int gp_spi_open(const char *spi_dev, uint8_t mode, uint32_t speed);

/**
 * @brief Writes a single byte to the SPI bus.
 *
 * @spi_fd An SPI bus file descriptor.
 * @byte A byte to transfer.
 *
 * @return Zero on success, non-zero otherwise.
 */
int gp_spi_write(int spi_fd, uint8_t byte);

/**
 * @brief Runs an SPI transfer.
 *
 * @spi_fd An SPI bus file descriptor.
 * @rx_buf A buffer for received data, may be NULL.
 * @tx_buf A buffer for transfered data, may be NULL.
 * @size The size of the rx_buf and tx_buf buffers.
 *
 * @return Zero on success, non-zero otherwise.
 */
int gp_spi_transfer(int spi_fd, uint8_t *rx_buf, uint8_t *tx_buf, size_t size);

/**
 * @brief Closes SPI bus.
 */
void gp_spi_close(int spi_fd);
-------------------------------------------------------------------------------

This is a very thin wrapper for the Linux userspace SPI driver (spidev). The
kernel takes care of the SPI signaling (RX, TX, CLK) as well as the CS (chip
select).

.SPI display
[source,c]
-------------------------------------------------------------------------------
struct gp_gpio_map {
	union {
		struct gp_gpio gpio[4];
		struct {
			struct gp_gpio reset;
			struct gp_gpio dc;
			struct gp_gpio pwr;
			struct gp_gpio busy;
		};
	};
};

struct gp_display_spi {
	int spi_fd;
	struct gp_gpio_map *gpio_map;
	...
};

int gp_display_spi_init(struct gp_display_spi *self,
                        const char *spi_dev, uint8_t mode, uint32_t speed,
			struct gp_gpio_map *map);

void gp_display_spi_exit(struct gp_display_spi *self);

void gp_display_spi_cmd(struct gp_display_spi *self, uint8_t cmd);

void gp_display_spi_data(struct gp_display_spi *self, uint8_t data);

void gp_display_spi_data_transfer(struct gp_display_spi *self,
                                  uint8_t *tx_buf, uint8_t *rx_buf, size_t len);

int gp_display_spi_busy(struct gp_display_spi *self);

void gp_display_spi_wait_ready(struct gp_display_spi *self, int ready);
-------------------------------------------------------------------------------

SPI display abstraction combines Linux SPI and GPIOs into a display driver
into a single entity.

The 'gp_display_spi_cmd()' turns off the 'dc' GPIO pin then writes the cmd byte
to the SPI bus. Similarily the 'gp_display_spi_data()' turns on the 'dc' GPIO
pin and writes the data byte to the SPI bus.

The 'gp_display_spi_busy()' function reads the 'busy' GPIO and returns its
value.
