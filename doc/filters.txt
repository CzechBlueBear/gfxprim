Context filters
---------------

Pixel filters for 'GP_Context'.

The context filter is basically a function that operates on context pixels.
The result may be stored into a new bitmap or placed to bitmap passed as
argument or, in some cases, the filter could be used 'in place' so the result
is stored into the same context as the one passed as filter source.

Common filter API
~~~~~~~~~~~~~~~~~

For convenience, the filters API is unified:

* Each filter returns pointer to destination context or 'NULL' on failure
* The first two arguments are source and destination
* The last argument is progress callback

Each filter function could be used in two modes.

By passing non-'NULL' argument as filter destination user requests result to
be stored into the destination context. The context must have correct pixel
type and the context size must be big enough to store the result.

For filters that work 'in-place' (which is explicitly said for each filter)
the source and the destination could be the same context. Note that this is
not expected to work if you do several overlapping subcontexts and pass these
as arguments.

When 'NULL' is passed as destination new context for storing the result is
allocated and returned. 

The return value is either pointer to destination context or 'NULL' either
when malloc(2) has failed or if the filter is not implemented for such
pixel_type, parameters, etc...

[source,c]
-------------------------------------------------------------------------------
/*
 * Filter common API.
 */
GP_Context *GP_FilterFoo(const GP_Context *src, GP_Context *dst,
                         foo params ...,
                         GP_ProgressCallback *callback);
-------------------------------------------------------------------------------


Filters also exists in _Raw variant (that just takes source context,
destination context, filters parameters and progress callback). These filter
APIs are used for internal implementation and shouldn't be called by user as
the destination is expected to be crafted exactly for storing the filter
result and there are 'NO' sanity checks in place.

'You could use these at your own risk'

[source,c]
-------------------------------------------------------------------------------
/*
 * Raw filter common api.
 */
void GP_FilterFoo_Raw(const GP_Context *src, GP_Context *dst,
                      foo params ...,
                      GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Point operation filters
~~~~~~~~~~~~~~~~~~~~~~~

Point operations are filters that works with pixels as with independent values
(the value of destination pixel depends only on the pixel on the same
coordinates in source image). All of these filters works 'in-place' and the
result has always the same size as the source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterBrightness(const GP_Context *src, GP_Context *dst,
                                int32_t inc, GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Brightness filter, increments all pixel channels by a fixed value.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterContrast(const GP_Context *src, GP_Context *dst, 
                              float mul, GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Contrast filter, multiplies all pixel channels by a fixed value.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterInvert(const GP_Context *src, GP_Context *dst,
                            GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Inverts the image, for each channel the result value is computed as "chan_max
- val".

Rotation and Symmetry filters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterMirrorH(const GP_Context *src, GP_Context *dst,
                             GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Mirrors context horizontally.

Works 'in-place'.

The destination has to have the same pixel type and the destination size must
be at least as big as source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterMirrorV(const GP_Context *src, GP_Context *dst,
                             GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Mirrors context vertically.

Works 'in-place'.

the destination has to have the same pixel type and the destination size must
be at least as big as source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterRotate90(const GP_Context *src, GP_Context *dst,
                              GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 90 degrees.

Doesn't work 'in-place' (yet).

The destination has to have the same pixel type and destination size must be
big enough to fit rotated context (i.e. W and H are swapped).

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterRotate180(const GP_Context *src, GP_Context *dst,
                               GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 180 degrees.

Doesn't work 'in-place' (yet).

the destination has to have the same pixel type and the destination size must
be at least as big as source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterRotate270(const GP_Context *src, GP_Context *dst,
                               GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 270 degrees.

Doesn't work 'in-place' (yet).

The destination has to have the same pixel type and destination size must be
big enough to fit rotated context (eg. W and H are swapped).

[source,c]
-------------------------------------------------------------------------------
typedef enum GP_FilterSymmetries {
        GP_ROTATE_90,
        GP_ROTATE_CW = GP_ROTATE_90,
        GP_ROTATE_180,
        GP_ROTATE_270,
        GP_ROTATE_CCW = GP_ROTATE_270,
        GP_MIRROR_H,
        GP_MIRROR_V,
} GP_FilterSymmetries;

GP_Context *GP_FilterSymmetry(const GP_Context *src, GP_Context *dst,
                              GP_FilterSymmetries symmetry,
                              GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Catch all function for symmetry filters.


Linear filters
~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterGaussianBlur(const GP_Context *src, GP_Context *dst,
                                  float sigma_x, float sigma_y,
                                  GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Gaussian blur filter.

Works 'in-place'.

'TODO:' this filter is implemented for RGB888 only.


Interpolation filters
~~~~~~~~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

typedef enum GP_InterpolationType {
        GP_INTERP_NN,    /* Nearest Neighbour */
        GP_INTERP_CUBIC, /* Bicubic           */
} GP_InterpolationType;

GP_Context *GP_FilterResize(const GP_Context *src, GP_Context *dst,
                            GP_InterpolationType type,
                            GP_Size w, GP_Size h,
                            GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Interpolate (resize) the context.

Doesn't work 'in-place' (this is quite impossible as the size of the bitmap is
changed by the filter).

If the filter destination is non 'NULL' and the 'w' and 'h' is smaller than the
destination size the source image is interpolated into subcontext of
destination defined by 'w' and 'h'.

'TODO:' this filter is implemented for RGB888 only.

Nearest Neighbour Interpolation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Fast, but produces "pixelated" images. May however work better for images with
sharp edges mostly consisting of big one color regions (it doesn't blur the
result on upscaling).

Bicubic Interpolation
^^^^^^^^^^^^^^^^^^^^^

Works well as is on image upscaling. To get decent result on downscaling
low-pass filter (Gaussian blur) must be used on original image before actual
downscaling. To do this reasonably fast we could cheat a little: first resize
big images a little without the low-pass filter, then apply low-pass filter and
finally downscale it to desired size.

Dithering
~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterFloydSteinberg_from_RGB888(const GP_Context *src,
                                                GP_Context *dst,
                                                GP_PixelType dst_pixel_type,
                                                GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Floyd-Steinberg dithering the source context must be RGB888 and the
dst_pixel_type may either be RGB or Grayscale.

Doesn't work 'in-place' as the result has different pixel type.

The error is distributed to neighbour pixels as follows:

[width="10%"]
|===================
|      |   X  | 7/16
| 3/16 | 5/16 | 1/16
|===================

And is throwed away at the image borders.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterFloydSteinberg_to_G1(const GP_Context *src,
                                          GP_Context *dst,
                                          GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Same as above but the source is any pixel type and the result is stored into
1-bit Grayscale.

Example Images
^^^^^^^^^^^^^^
All following images were generated using 'grinder'.
(Click for bigger size)

.Original Image; 1-bit, 2-bit, 4-bit Grayscale; 1-bit, 2-bit, 3-bit RGB
image:images/dither/lenna_small.png[
	"Original Image", 
	link="images/dither/lenna.png"]
image:images/dither/lenna_G1_small.png[
	"1-bit Grayscale",
	link="images/dither/lenna_G1.png"]
image:images/dither/lenna_G2_small.png[
	"2-bit Grayscale",
	link="images/dither/lenna_G2.png"]
image:images/dither/lenna_G4_small.png[
	"4-bit Grayscale",
	link="images/dither/lenna_G4.png"]
image:images/dither/lenna_RGB111_small.png[
	"1-bit RGB",
	link="images/dither/lenna_RGB111.png"]
image:images/dither/lenna_RGB222_small.png[
	"2-bit RGB",
	link="images/dither/lenna_RGB222.png"]
image:images/dither/lenna_RGB333_small.png[
	"3-bit RGB",
	link="images/dither/lenna_RGB333.png"]

