Context filters
---------------

Pixel filters for 'GP_Context'.

The context filter is basically a function that operates on context pixels.
The result may be stored into a new bitmap or placed to bitmap passed as
argument or, in some cases, the filter could be used 'in place' so the result
is stored into the same context as the one passed as filter source.

Common filter API
~~~~~~~~~~~~~~~~~

For convenience, the filters API is unified:

* There are two functions for each filter
  - first one takes destination as an argument
  - second one allocates the destination and returns pointer to it
* First argument(s) are always source(s)
* Then, in case of second variant, destination
* Other parameters follow
* And the last argument is progress callback

When using allocating version of the filter, pointer to the newly allocated
context is returned, or in case of failure 'NULL' is returned.

If 'malloc()' has failed 'NULL' is returned.

If filter has been interrupted by a callback, all allocated memory is freed,
and 'NULL' is returned.

When using non-allocating variant of the filter, the destination context must
have correct pixel type and the size must be big enough to store the result.
The return value from such filter is either zero, in case of success, or
non-zero when filter was interrupted by a callback.

For filters that work 'in-place' (which is explicitly said for each filter)
the source and the destination could be the same context. Note that this is
not expected to work if you do several overlapping sub-contexts and pass these
as arguments.

[source,c]
-------------------------------------------------------------------------------
/*
 * Filter common API.
 */
int GP_FilterFoo(const GP_Context *src, GP_Context *dst,
                 foo params ...,
                 GP_ProgressCallback *callback);

GP_Context *GP_FilterFooAlloc(const GP_Context *src,
                              foo params ...,
                              GP_ProgressCallback *callback);
-------------------------------------------------------------------------------


Filters also exists in _Raw variant whose interface is similar to the first
type of filter function. These filter APIs are used for internal
implementation and shouldn't be called by user as the destination is expected
to be crafted exactly for storing the filter result and there are 'NO' sanity
checks in place.

'You could use these at your own risk'

[source,c]
-------------------------------------------------------------------------------
/*
 * Raw filter common API.
 */
int GP_FilterFoo_Raw(const GP_Context *src, GP_Context *dst,
                     foo params ...,
                     GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Filter Parameters
~~~~~~~~~~~~~~~~~

In order to pass, per-channel, filter parameters to a filter, structure called
GP_FilterParams was created.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <filters/GP_FilterParam.h>

typedef union GP_FilterParamVal {
        float f;
        uint32_t ui;
        int32_t i;
        void *ptr;
} GP_FilterParamVal;

typedef struct GP_FilterParam {
	char channel_name[2];
	union GP_FilterParamVal val;
} GP_FilterParam;
-------------------------------------------------------------------------------

Some filters do take an empty channel_name terminated (empty channel_name is
empty string i.e. "\0") array of GP_FilterParam, which is used to describe
per-channel parameters.


There are two methods how to construct GP_FilterParam structure. First one is
to use macro that expands to a code which declares and initializes the array on
the stack second uses memory allocated by a malloc(). In both cases the
structure is has initialized channel names and terminator.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <filters/GP_FilterParam.h>

#define GP_FILTER_PARAMS(pixel_type, name) \
        GP_FilterParam name[GP_PixelTypes[pixel_type].numchannels + 1]; \
        GP_FilterParamInitChannels(name, pixel_type);
-------------------------------------------------------------------------------

Macro that declares and initializes GP_FilterParam structure for a given
pixel_type.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <filters/GP_FilterParam.h>

GP_FilterParam *GP_FilterParamCreate(GP_PixelType pixel_type);

void GP_FilterParamDestroy(GP_FilterParam *self);
-------------------------------------------------------------------------------

Second possible way allocates memory using malloc().

Functions for manipulating and querying existing GP_FilterParam follows.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <filters/GP_FilterParam.h>

void GP_FilterParamInitChannels(GP_FilterParam params[],
                                GP_PixelType pixel_type);
-------------------------------------------------------------------------------

Initializes filter param array channel names (accordingly to pixel type) and
terminator. The params array must be large enough to hold number of pixel type
channels plus one.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <filters/GP_FilterParam.h>

GP_FilterParam *GP_FilterParamChannel(GP_FilterParam params[],
                                      const char *channel_name);
-------------------------------------------------------------------------------

Does lookup for a given channel name and returns, if found, corresponding
GP_FilterParam, otherwise 'NULL' is returned.

This function is primary used in filters, where filter, at the start, resolves
all it's parameters.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <filters/GP_FilterParam.h>

int GP_FilterParamCheckPixelType(GP_FilterParam params[],
                                 GP_PixelType pixel_type);
-------------------------------------------------------------------------------

Matches param structure against pixel_type. Returns zero if params describes
exactly same channels like pixel_type, non-zero otherwise.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>
/* or */
#include <filters/GP_FilterParam.h>

void GP_FilterParamSetIntAll(GP_FilterParam params[], int32_t val);

int GP_FilterParamSetInt(GP_FilterParam params[], const char *channel_name,
                         int32_t val);

void GP_FilterParamSetFloatAll(GP_FilterParam params[], float val);

int GP_FilterParamSetFloat(GP_FilterParam params[], const char *channel_name,
                           float val);

void GP_FilterParamSetUIntAll(GP_FilterParam params[], uint32_t val);

int GP_FilterParamSetUInt(GP_FilterParam params[], const char *channel_name,
                          uint32_t val);

void GP_FilterParamSetPtrAll(GP_FilterParam params[], void *ptr);

int GP_FilterParamSetPtr(GP_FilterParam params[], const char *channel_name,
                         void *ptr);

void GP_FilterParamFreePtrAll(GP_FilterParam params[]);
-------------------------------------------------------------------------------

Parameter setters. Those that sets individual value returns zero on success
(i.e. channel was found) and non-zero otherwise.

The last one calls free() on all param pointers, which is used to free
allocate memory.

Point operation filters
~~~~~~~~~~~~~~~~~~~~~~~

Point operations are filters that works with pixels as with independent values
(the value of destination pixel depends only on the pixel on the same
coordinates in source image). All of these filters works 'in-place' and the
result has always the same size as the source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterBrightness(const GP_Context *src, GP_Context *dst,
                                int32_t inc, GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Brightness filter, increments all pixel channels by a fixed value.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterContrast(const GP_Context *src, GP_Context *dst, 
                              float mul, GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Contrast filter, multiplies all pixel channels by a fixed value.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterInvert(const GP_Context *src, GP_Context *dst,
                            GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Inverts the image, for each channel the result value is computed as "chan_max
- val".

Arithmetic filters
~~~~~~~~~~~~~~~~~~

Arithmetic filters do take two contexts as an input and combines them into one
output context.

The pixel type of both input contexts must match.

If size of the input contexts differs, minimum is used.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Arithmetic.h>
/* or */
#include <GP.h>

int GP_FilterAddition(const GP_Context *src_a,
                      const GP_Context *src_b,
                      GP_Context *dst,
                      GP_ProgressCallback *callback);

GP_Context *GP_FilterAdditionAlloc(const GP_Context *src_a,
                                   const GP_Context *src_b,
                                   GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Produces saturated (clamped) addition of two contexts.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Arithmetic.h>
/* or */
#include <GP.h>

int GP_FilterMultiply(const GP_Context *src_a,
                      const GP_Context *src_b,
                      GP_Context *dst,
                      GP_ProgressCallback *callback);

GP_Context *GP_FilterMultiplyAlloc(const GP_Context *src_a,
                                   const GP_Context *src_b,
                                   GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Produces saturated (clamped) multiplication of two contexts.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Arigthmetic.h>
/* or */
#include <GP.h>

int GP_FilterDifference(const GP_Context *src_a,
                        const GP_Context *src_b,
                        GP_Context *dst,
                        GP_ProgressCallback *callback);

GP_Context *GP_FilterDifferenceAlloc(const GP_Context *src_a,
                                     const GP_Context *src_b,
                                     GP_ProgressCallback *callback);

-------------------------------------------------------------------------------

Produces symmetric difference (i.e. abs(a - b)).

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Arigthmetic.h>
/* or */
#include <GP.h>

int GP_FilterMax(const GP_Context *src_a,
                 const GP_Context *src_b,
                 GP_Context *dst,
                 GP_ProgressCallback *callback);

GP_Context *GP_FilterMaxAlloc(const GP_Context *src_a,
                              const GP_Context *src_b,
                              GP_ProgressCallback *callback);

int GP_FilterMin(const GP_Context *src_a,
                 const GP_Context *src_b,
                 GP_Context *dst,
                 GP_ProgressCallback *callback);

GP_Context *GP_FilterMinAlloc(const GP_Context *src_a,
                              const GP_Context *src_b,
                              GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Maximum and minimum filter.

Rotation and Symmetry filters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Rotate.h>
/* or */
#include <GP.h>

int GP_FilterMirrorH(const GP_Context *src, GP_Context *dst,
                     GP_ProgressCallback *callback);

GP_Context *GP_FilterMirrorH_Alloc(const GP_Context *src,
                                   GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Mirrors context horizontally.

Works 'in-place'.

The destination has to have the same pixel type and the size must be at least
as large as source.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Rotate.h>
/* or */
#include <GP.h>

int GP_FilterMirrorV(const GP_Context *src, GP_Context *dst,
                     GP_ProgressCallback *callback);

GP_Context *GP_FilterMirrorV_Alloc(const GP_Context *src,
                                   GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Mirrors context vertically.

Works 'in-place'.

The destination has to have the same pixel type and the size must be at least
as large as source.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Rotate.h>
/* or */
#include <GP.h>

int GP_FilterRotate90(const GP_Context *src, GP_Context *dst,
                      GP_ProgressCallback *callback);

GP_Context *GP_FilterRotate90_Alloc(const GP_Context *src,
                                    GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 90 degrees.

Doesn't work 'in-place' (yet).

The destination has to have the same pixel type and size must be large enough to
fit rotated context (i.e. W and H are swapped).

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Rotate.h>
/* or */
#include <GP.h>

int GP_FilterRotate180(const GP_Context *src, GP_Context *dst,
                       GP_ProgressCallback *callback);

GP_Context *GP_FilterRotate180_Alloc(const GP_Context *src,
                                     GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 180 degrees.

Doesn't work 'in-place' (yet).

The destination has to have the same pixel type and the size must be at least
as large as source.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Rotate.h>
/* or */
#include <GP.h>

int GP_FilterRotate270(const GP_Context *src, GP_Context *dst,
                       GP_ProgressCallback *callback);

GP_Context *GP_FilterRotate270_Alloc(const GP_Context *src,
                                     GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 270 degrees.

Doesn't work 'in-place' (yet).

The destination has to have the same pixel type and destination size must be
large enough to fit rotated context (i.e. W and H are swapped).

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Rotate.h>
/* or */
#include <GP.h>

typedef enum GP_FilterSymmetries {
        GP_ROTATE_90,
        GP_ROTATE_CW = GP_ROTATE_90,
        GP_ROTATE_180,
        GP_ROTATE_270,
        GP_ROTATE_CCW = GP_ROTATE_270,
        GP_MIRROR_H,
        GP_MIRROR_V,
} GP_FilterSymmetries;

GP_Context *GP_FilterSymmetry(const GP_Context *src,
                              GP_FilterSymmetries symmetry,
                              GP_ProgressCallback *callback);

int GP_FilterSymmetry(const GP_Context *src, GP_Context *dst,
                      GP_FilterSymmetries symmetry,
                      GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Catch all function for symmetry filters.


Linear filters
~~~~~~~~~~~~~~

Linear filters family consists of filters based on discrete linear
convolution, that means that computed pixel value depends on linear
combination of the image pixels.

It's defined as:
[latex, discrete_linear_convolution.png, 140]
-------------------------------------------------------------------------------
\[
O(x,y)=\sum_{i=-\infty}^{\infty}\sum_{j=-\infty}^{\infty}I(x+i,y+j) \cdot K(i,j)
\]
-------------------------------------------------------------------------------

The K denotes convolution kernel and in practice, due to computational
complexity i and j are bounded in relatively small intervals. For example i
and j are in (-1,1) and the kernel size is 3x3.

Note that pixel values outside the image are undefined. The linear convolution
in GFXprim simply uses the closest border pixel values for all pixels outside
the image.

Particular convolution kernel is called separable if it could be decomposed
into two one dimensional kernels (these when combined yields back the original
kernel). Such convolution then could be applied as two one dimensional
convolutions which is faster operation (especially for big kernels).

Generic Linear Convolution
^^^^^^^^^^^^^^^^^^^^^^^^^^

Following paragraph describes linear convolution implementation as well as a
little of the math background skip it if you just need to use one of the
ready-to-use filters.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Linear.h>
/* or */
#include <GP.h>

int GP_FilterLinearConvolution_Raw(const GP_Context *src,
                                   GP_Coord x_src, GP_Coord y_src,
                                   GP_Size w_src, GP_Size h_src,
                                   GP_Context *dst,
                                   GP_Coord x_dst, GP_Coord y_dst,
                                   float kernel[], uint32_t kw, uint32_t kh,
                                   float kern_div, GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Internal generic convolution filter, this is a base for all linear convolution
filters with non-separable kernel.

The src coordinate and sizes denotes rectangle in the source context that the
filter operates on.

The dst coordinates defines offset into the dst context.

The kernel is two-dimensional array of a size kw * kh indexed as
kernel[x + y*kw]. 

The kern_div is a coefficient that is used to divide the resulting values often
used to normalize the result.

This filter works 'in-place'.

The pixel value is computed as:
[latex, discrete_linear_convolution_alg1.png, 140]
-------------------------------------------------------------------------------
\[
O(x,y)={1 \over kern\_div} \cdot \sum_{i=0}^{kw - 1}\sum_{j=0}^{kh - 1}
       I(x + i - \lfloor kw/2 \rfloor, y + j - \lfloor kh/2 \rfloor)
       \cdot kernel(i,j)
\]
-------------------------------------------------------------------------------

Which is the same as:

[latex, discrete_linear_convolution_alg2.png, 140]
-------------------------------------------------------------------------------
\[
O(x,y)={1 \over kern\_div} \cdot
       \sum_{i=-\lfloor kw/2 \rfloor}^{\lfloor kw/2 \rfloor}
       \sum_{j=-\lfloor kh/2 \rfloor}^{\lfloor kh/2 \rfloor}
       I(x + i, y + j)
       \cdot kernel(i + \lfloor kw/2 \rfloor, j + \lfloor kh/2 \rfloor)
\]
-------------------------------------------------------------------------------

NOTE: The number of kernel rows and columns is expected to be odd number.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Linear.h>
/* or */
#include <GP.h>

int GP_FilterHLinearConvolution_Raw(const GP_Context *src,
                                    GP_Coord x_src, GP_Coord y_src,
                                    GP_Size w_src, GP_Size h_src,
                                    GP_Context *dst,
                                    GP_Coord x_dst, GP_Coord y_dst,
                                    float kernel[], uint32_t kw, float kern_div,
                                    GP_ProgressCallback *callback);

int GP_FilterVLinearConvolution_Raw(const GP_Context *src,
                                    GP_Coord x_src, GP_Coord y_src,
                                    GP_Size w_src, GP_Size h_src,
                                    GP_Context *dst,
                                    GP_Coord x_dst, GP_Coord y_dst,
                                    float kernel[], uint32_t kh, float kern_div,
                                    GP_ProgressCallback *callback);

int GP_FilterVHLinearConvolution_Raw(const GP_Context *src,
                                     GP_Coord x_src, GP_Coord y_src,
                                     GP_Size w_src, GP_Size h_src,
                                     GP_Context *dst,
                                     GP_Coord x_dst, GP_Coord y_dst,
                                     float hkernel[], uint32_t kw, float hkern_div,
                                     float vkernel[], uint32_t kh, float vkern_div,
                                     GP_ProgressCallback *callback);

void GP_FilterKernelPrint_Raw(float kernel[], int kw, int kh, float kern_div);
-------------------------------------------------------------------------------

Internal special functions for one dimensional vertical and horizontal
convolution these two functions are base for all separable convolution filters.

The src coordinate and sizes denotes rectangle in the source context that the
filter operates on.

The dst coordinates are offset into the dst.

The kernel is one-dimensional array of floats of size kw or kh.

The kern_div is a coefficient that is used to divide the resulting values. 

The last function does both vertical and horizontal convolution and takes care
of correct progress callback.

These filters work 'in-place'.

The pixel value is computed as:
[latex, discrete_linear_1D_convolution_alg1.png, 140]
-------------------------------------------------------------------------------
\[
O(x,y)={1 \over kern\_div} \cdot \sum_{i=0}^{kw - 1}
       I(x + i - \lfloor kw/2 \rfloor, y)
       \cdot kernel(i)
\]

\[
O(x,y)={1 \over kern\_div} \cdot \sum_{j=0}^{kw - 1}
       I(x, y + j - \lfloor kh/2 \rfloor)
       \cdot kernel(j)
\]
-------------------------------------------------------------------------------

Which is the same as:

[latex, discrete_linear_1D_convolution_alg2.png, 140]
-------------------------------------------------------------------------------
\[
O(x,y)={1 \over kern\_div} \cdot
       \sum_{i=-\lfloor kw/2 \rfloor}^{\lfloor kw/2 \rfloor}
       I(x + i, y)
       \cdot kernel(i + \lfloor kw/2 \rfloor)
\]

\[
O(x,y)={1 \over kern\_div} \cdot
       \sum_{j=-\lfloor kh/2 \rfloor}^{\lfloor kh/2 \rfloor}
       I(x, y + j)
       \cdot kernel(i, j + \lfloor kh/2 \rfloor)
\]
-------------------------------------------------------------------------------

NOTE: The number of kernel rows and columns is expected to be odd number.

NOTE: The linear convolutions are internally implemented using integer
      arithmetics, which works fine, but you need to take a care not to
      overflow 32bit signed integer. If the pixel channel size is 8bit
      long and 10bits are used for the fixed point part of the number 
      the rest must fit into about 10 bits to be safe.

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Convolution.h>
/* or */
#include <GP.h>

typedef struct GP_FilterKernel2D {
	unsigned int w;
	unsigned int h;
	float div;
	float *kernel;
} GP_FilterKernel2D;

int GP_FilterConvolutionEx(const GP_Context *src,
                           GP_Coord x_src, GP_Coord y_src,
                           GP_Size w_src, GP_Coord h_src,
                           GP_Context *dst,
                           GP_Coord x_dst, GP_Coord y_dst,
                           const GP_FilterKernel2D *kernel,
                           GP_ProgressCallback *callback);

GP_Context *GP_FilterConvolutionExAlloc(const GP_Context *src,
                                        GP_Coord x_src, GP_Coord y_src,
                                        GP_Size w_src, GP_Size h_src,
                                        const GP_FilterKernel2D *kernel,
                                        GP_ProgressCallback *callback);

int GP_FilterConvolution(const GP_Context *src, GP_Context *dst,
                         const GP_FilterKernel2D *kernel,
                         GP_ProgressCallback *callback);

GP_Context *GP_FilterConvolutionAlloc(const GP_Context *src,
                                      const GP_FilterKernel2D *kernel,
                                      GP_ProgressCallback *callback);

void GP_FilterKernel2DPrint(const GP_FilterKernel2D *kernel);
-------------------------------------------------------------------------------

Linear convolution filters, you should preferably use this API over the _Raw
variants.

The Ex variants takes a rectangle on which the filter should operate as well
as offset into the destination. The destination must be large enough so that
starting with offset there is at least w_dst and h_dst pixels.

The kernel is a pointer to a structure initialized with the kernel size, divider
and array of kernel values.

The last function prints convolution kernel in human-readable format into the
stdout.

[source,c]
-------------------------------------------------------------------------------
#include <GP.h>

/*
 * Example box smoothing filter.
 */
static void box_smoothing(GP_Context *img)
{
	float box_filter[] = {
		1, 1, 1,
		1, 1, 1,
		1, 1, 1,
	};

	GP_FilterKernel2D box_kernel = {
		.w = 3,
		.h = 3,
		.div = 9,
		.kernel = box_filter,
	};

	GP_FilterConvolution(img, img, &box_kernel, NULL);
}
-------------------------------------------------------------------------------

Example function that implements simple 'in-place' smoothing filter.

Laplace Filter
^^^^^^^^^^^^^^

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>
/* or */
#include <GP.h>

int GP_FilterLaplace(const GP_Context *src, GP_Context *dst,
                     GP_ProgressCallback *callback);

GP_Context *GP_FilterLaplaceAlloc(const GP_Context *src,
                                  GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Discrete Laplace filter that produces a second derivative of the original
image.

The convolution kernel is defined as:

[latex, laplacian_kernel.png, 130]
-------------------------------------------------------------------------------
\[
\begin{bmatrix}
0  &  1  &  0 \\
0  & -2  &  0 \\
0  &  1  &  0
\end{bmatrix}
+
\begin{bmatrix}
0  &  0  &  0 \\
1  & -2  &  1 \\
0  &  0  &  0 
\end{bmatrix}
=
\begin{bmatrix}
0  &  1  &  0 \\
1  & -4  &  1 \\
0  &  1  &  0
\end{bmatrix}
\]
-------------------------------------------------------------------------------

NOTE: This filter is not separable but could be written as a sum of two one
      dimensional filters as the kernel definition suggests.

Laplacian Edge Sharpening
^^^^^^^^^^^^^^^^^^^^^^^^^

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>
/* or */
#include <GP.h>

int GP_FilterEdgeSharpening(const GP_Context *src, GP_Context *dst,
                            float w, GP_ProgressCallback *callback);

GP_Context *GP_FilterEdgeSharpeningAlloc(const GP_Context *src, float w,
                                         GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Laplace based edge sharpening filter, subtracts weighted second derivative
from the original image.

[latex, laplacian_edge_sharpening.png, 140]
-------------------------------------------------------------------------------
\[
O(x,y) = I(x,y) - w * I''(x,y)
\]
-------------------------------------------------------------------------------

.Original Image; Edge Sharpening w=0.1, w=0.3, w=0.5
image:images/dither/lenna_small.png[
	"Original Image", 
	link="images/dither/lenna.png"]
image:images/edge_sharpening/lenna_small_w_0_1.png[
	"Edge Sharpening w=0.1", 
	link="images/edge_sharpening/lenna_w_0_1.png"]
image:images/edge_sharpening/lenna_small_w_0_3.png[
	"Edge Sharpening w=0.5", 
	link="images/edge_sharpening/lenna_w_0_3.png"]
image:images/edge_sharpening/lenna_small_w_0_5.png[
	"Edge Sharpening w=0.5", 
	link="images/edge_sharpening/lenna_w_0_5.png"]

Gaussian Blur
^^^^^^^^^^^^^

[source,c]
-------------------------------------------------------------------------------
#include <filters/GP_Blur.h>
/* or */
#include <GP.h>

int GP_FilterGaussianBlurEx(const GP_Context *src,
                            GP_Coord x_src, GP_Coord y_src,
                            GP_Size w_src, GP_Size h_src,
                            GP_Context *dst,
                            GP_Coord x_dst, GP_Coord y_dst,
                            float x_sigma, float y_sigma,
                            GP_ProgressCallback *callback);

GP_Context *GP_FilterGaussianBlurExAlloc(const GP_Context *src,
                                         GP_Coord x_src, GP_Coord y_src,
                                         GP_Size w_src, GP_Size h_src,
                                         float x_sigma, float y_sigma,
                                         GP_ProgressCallback *callback);

int GP_FilterGaussianBlur(const GP_Context *src, GP_Context *dst,
                          float x_sigma, float y_sigma,
                          GP_ProgressCallback *callback)

GP_Context *GP_FilterGaussianBlurAlloc(const GP_Context *src,
                                       float x_sigma, float y_sigma,
                                       GP_ProgressCallback *callback)
-------------------------------------------------------------------------------

Gaussian blur (low pass) filters implemented as bilinear separable
convolution.

The sigma denotes amount of the blur (the radius is computed accordingly
automatically).

The sigma values can be set for vertical and horizontal direction
independently which may be useful when Gaussian blur is used as a low pass
filter before image is resampled non proportionally.

Interpolation filters
~~~~~~~~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

typedef enum GP_InterpolationType {
        GP_INTERP_NN,            /* Nearest Neighbour                         */
        GP_INTERP_LINEAR_INT,    /* Bilinear - fixed point arithmetics        */
        GP_INTERP_LINEAR_LF_INT, /* Bilinear + low pass filter on downscaling */
        GP_INTERP_CUBIC,         /* Bicubic                                   */
        GP_INTERP_CUBIC_INT,     /* Bicubic - fixed point arithmetics         */
        GP_INTERP_MAX = GP_INTERP_CUBIC_INT,
} GP_InterpolationType;

GP_Context *GP_FilterResize(const GP_Context *src, GP_Context *dst,
                            GP_InterpolationType type,
                            GP_Size w, GP_Size h,
                            GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Interpolate (resize) the context.

Doesn't work 'in-place' (this is quite impossible as the size of the bitmap is
changed by the filter).

If the filter destination is non 'NULL' and the 'w' and 'h' is smaller than the
destination size the source image is interpolated into sub-context of
destination defined by 'w' and 'h'.

'TODO:' this filter is implemented for RGB888 only.

Nearest Neighbour Interpolation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Fast, but produces "pixelated" images. May however work better for images with
sharp edges mostly consisting of big one color regions (it doesn't blur the
result on upscaling).

Also is commonly used to show preview before you resample the image correctly.

Bilinear Interpolation
^^^^^^^^^^^^^^^^^^^^^^

Bilinear is faster than bicubic interpolation and produces quite good results
especially the low pass variant doesn't need additional filter on down-sampling.

Bicubic Interpolation
^^^^^^^^^^^^^^^^^^^^^

Works well as is on image upscaling. To get decent result on downscaling
low-pass filter (Gaussian blur) must be used on original image before actual
downscaling. To do this reasonably fast we could cheat a little: first resize
big images a little without the low-pass filter, then apply low-pass filter and
finally downscale it to desired size.

Dithering
~~~~~~~~~

Currently there are two dithering algorithms implemented. Both takes an RGB888
24bit image as input and are able to produce any RGB or Grayscale image.
This filters doesn't work 'in-place' as the result has different pixel type.

Floyd-Steinberg
^^^^^^^^^^^^^^^

Classical Floyd-Steinberg. Produces good results and is a little faster than
the Hilbert-Peano dithering.

The error is distributed to neighbor pixels as follows:

[width="10%"]
|===================
|      |   X  | 7/16
| 3/16 | 5/16 | 1/16
|===================

And is throwed away at the image borders.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterFloydSteinberg_RGB888(const GP_Context *src,
                                   GP_Context *dst,
                                   GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Renders Floyd Steinberg dithering directly into passed context. The
destination must be at least as large as source. 

If operation was aborted by a callback, non-zero is returned.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterFloydSteinberg_RGB888_Alloc(const GP_Context *src,
                                                 GP_PixelType pixel_type,
                                                 GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Returns pointer to allocated context of given pixel_type.

If malloc(2) has failed, or operation was aborted by a callback 'NULL' is
returned.

Hilbert-Peano
^^^^^^^^^^^^^

Hilbert-Peano space filling curve based dithering.
 
The error value is distributed around the Hilbert curve.

The result is a little more noisy, but doesn't create repeating patterns like
Floyd-Steinberg which looks generally better to human eye. On the other hand
edges tend to be less sharp.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterHilbertPeano_RGB888(const GP_Context *src,
                                 GP_Context *dst,
                                 GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Renders Hilbert Peano dithering directly into passed context. The
destination must be at least as large as source. 

If operation was aborted by a callback, non-zero is returned.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterHilbertPeano_RGB888_Alloc(const GP_Context *src,
                                               GP_PixelType pixel_type,
                                               GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Returns pointer to allocated context of given pixel_type.

If malloc(2) has failed, or operation was aborted by a callback 'NULL' is
returned.

Example Images
^^^^^^^^^^^^^^
All following images were generated using 'grinder'.
(Click for bigger size)

.Original Image; Floyd-Steinberg, Hilbert-Peano: 1-bit, 2-bit, 4-bit, 8-bit Grayscale; 1-bit, 2-bit, 3-bit (per channel) RGB
image:images/dither/lenna_small.png[
	"Original Image", 
	link="images/dither/lenna.png"]
image:images/dither/lenna_G1_FS_small.png[
	"1-bit Grayscale Floyd-Steinberg",
	link="images/dither/lenna_G1_FS.png"]
image:images/dither/lenna_G1_HP_small.png[
	"1-bit Grayscale Hilbert-Peano",
	link="images/dither/lenna_G1_HP.png"]
image:images/dither/lenna_G2_FS_small.png[
	"2-bit Grayscale Floyd-Steinberg",
	link="images/dither/lenna_G2_FS.png"]
image:images/dither/lenna_G2_HP_small.png[
	"2-bit Grayscale Hilbert-Peano",
	link="images/dither/lenna_G2_HP.png"]
image:images/dither/lenna_G4_FS_small.png[
	"4-bit Grayscale Floyd-Steinberg",
	link="images/dither/lenna_G4_FS.png"]
image:images/dither/lenna_G4_HP_small.png[
	"4-bit Grayscale Hilbert-Peano",
	link="images/dither/lenna_G4_HP.png"]
image:images/dither/lenna_G8_FS_small.png[
	"8-bit Grayscale Floyd-Steinberg",
	link="images/dither/lenna_G8_FS.png"]
image:images/dither/lenna_G8_HP_small.png[
	"7-bit Grayscale Hilbert-Peano",
	link="images/dither/lenna_G8_HP.png"]
image:images/dither/lenna_RGB111_FS_small.png[
	"1-bit RGB Floyd-Steinberg",
	link="images/dither/lenna_RGB111_FS.png"]
image:images/dither/lenna_RGB111_HP_small.png[
	"1-bit RGB Hilbert-Peano",
	link="images/dither/lenna_RGB111_HP.png"]
image:images/dither/lenna_RGB222_FS_small.png[
	"2-bit RGB Floyd-Steinberg",
	link="images/dither/lenna_RGB222_FS.png"]
image:images/dither/lenna_RGB222_HP_small.png[
	"2-bit RGB Hilbert-Peano",
	link="images/dither/lenna_RGB222_HP.png"]
image:images/dither/lenna_RGB333_FS_small.png[
	"3-bit RGB Floyd-Steinberg",
	link="images/dither/lenna_RGB333_FS.png"]
image:images/dither/lenna_RGB333_HP_small.png[
	"3-bit RGB Hilbert-Peano",
	link="images/dither/lenna_RGB333_HP.png"]

