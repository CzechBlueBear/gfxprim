Context filters
---------------

Pixel filters for 'GP_Context'.

The context filter is basically a function that operates on context pixels.
The result may be stored into a new bitmap or placed to bitmap passed as
argument or, in some cases, the filter could be used 'in place' so the result
is stored into the same context as the one passed as filter source.

Common filter API
~~~~~~~~~~~~~~~~~

For convenience, the filters API is unified:

* Each filter returns pointer to destination context or 'NULL' on failure
* The first two arguments are source and destination
* The last argument is progress callback

Each filter function could be used in two modes.

By passing non-'NULL' argument as filter destination user requests result to
be stored into the destination context. The context must have correct pixel
type and the context size must be big enough to store the result.

For filters that work 'in-place' (which is explicitly said for each filter)
the source and the destination could be the same context. Note that this is
not expected to work if you do several overlapping subcontexts and pass these
as arguments.

When 'NULL' is passed as destination new context for storing the result is
allocated and returned. 

The return value is either pointer to destination context or 'NULL' either
when malloc(2) has failed or if the filter is not implemented for such
pixel_type, parameters, etc...

[source,c]
-------------------------------------------------------------------------------
/*
 * Filter common API.
 */
GP_Context *GP_FilterFoo(const GP_Context *src, GP_Context *dst,
                         foo params ...,
                         GP_ProgressCallback *callback);
-------------------------------------------------------------------------------


Filters also exists in _Raw variant (that just takes source context,
destination context, filters parameters and progress callback). These filter
APIs are used for internal implementation and shouldn't be called by user as
the destination is expected to be crafted exactly for storing the filter
result and there are 'NO' sanity checks in place.

'You could use these at your own risk'

[source,c]
-------------------------------------------------------------------------------
/*
 * Raw filter common API.
 */
void GP_FilterFoo_Raw(const GP_Context *src, GP_Context *dst,
                      foo params ...,
                      GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Point operation filters
~~~~~~~~~~~~~~~~~~~~~~~

Point operations are filters that works with pixels as with independent values
(the value of destination pixel depends only on the pixel on the same
coordinates in source image). All of these filters works 'in-place' and the
result has always the same size as the source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterBrightness(const GP_Context *src, GP_Context *dst,
                                int32_t inc, GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Brightness filter, increments all pixel channels by a fixed value.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterContrast(const GP_Context *src, GP_Context *dst, 
                              float mul, GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Contrast filter, multiplies all pixel channels by a fixed value.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterInvert(const GP_Context *src, GP_Context *dst,
                            GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Inverts the image, for each channel the result value is computed as "chan_max
- val".

Rotation and Symmetry filters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterMirrorH(const GP_Context *src, GP_Context *dst,
                     GP_ProgressCallback *callback);

GP_Context *GP_FilterMirrorH_Alloc(const GP_Context *src,
                                   GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Mirrors context horizontally.

Works 'in-place'.

The destination has to have the same pixel type and the size must be at least
as large as source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterMirrorV(const GP_Context *src, GP_Context *dst,
                     GP_ProgressCallback *callback);

GP_Context *GP_FilterMirrorV_Alloc(const GP_Context *src,
                                   GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Mirrors context vertically.

Works 'in-place'.

The destination has to have the same pixel type and the size must be at least
as large as source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterRotate90(const GP_Context *src, GP_Context *dst,
                      GP_ProgressCallback *callback);

GP_Context *GP_FilterRotate90_Alloc(const GP_Context *src,
                                    GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 90 degrees.

Doesn't work 'in-place' (yet).

The destination has to have the same pixel type and size must be large enough to
fit rotated context (i.e. W and H are swapped).

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterRotate180(const GP_Context *src, GP_Context *dst,
                       GP_ProgressCallback *callback);

GP_Context *GP_FilterRotate180_Alloc(const GP_Context *src,
                                     GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 180 degrees.

Doesn't work 'in-place' (yet).

The destination has to have the same pixel type and the size must be at least
as large as source.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterRotate270(const GP_Context *src, GP_Context *dst,
                       GP_ProgressCallback *callback);

GP_Context *GP_FilterRotate270_Alloc(const GP_Context *src,
                                     GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Rotate context by 270 degrees.

Doesn't work 'in-place' (yet).

The destination has to have the same pixel type and destination size must be
large enough to fit rotated context (eg. W and H are swapped).

[source,c]
-------------------------------------------------------------------------------
typedef enum GP_FilterSymmetries {
        GP_ROTATE_90,
        GP_ROTATE_CW = GP_ROTATE_90,
        GP_ROTATE_180,
        GP_ROTATE_270,
        GP_ROTATE_CCW = GP_ROTATE_270,
        GP_MIRROR_H,
        GP_MIRROR_V,
} GP_FilterSymmetries;

GP_Context *GP_FilterSymmetry(const GP_Context *src,
                              GP_FilterSymmetries symmetry,
                              GP_ProgressCallback *callback);

int GP_FilterSymmetry(const GP_Context *src, GP_Context *dst,
                      GP_FilterSymmetries symmetry,
                      GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Catch all function for symmetry filters.


Linear filters
~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterGaussianBlur(const GP_Context *src, GP_Context *dst,
                                  float sigma_x, float sigma_y,
                                  GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Gaussian blur filter.

Works 'in-place'.

'TODO:' this filter is implemented for RGB888 only.


Interpolation filters
~~~~~~~~~~~~~~~~~~~~~

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

typedef enum GP_InterpolationType {
        GP_INTERP_NN,    /* Nearest Neighbour */
        GP_INTERP_CUBIC, /* Bicubic           */
} GP_InterpolationType;

GP_Context *GP_FilterResize(const GP_Context *src, GP_Context *dst,
                            GP_InterpolationType type,
                            GP_Size w, GP_Size h,
                            GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Interpolate (resize) the context.

Doesn't work 'in-place' (this is quite impossible as the size of the bitmap is
changed by the filter).

If the filter destination is non 'NULL' and the 'w' and 'h' is smaller than the
destination size the source image is interpolated into subcontext of
destination defined by 'w' and 'h'.

'TODO:' this filter is implemented for RGB888 only.

Nearest Neighbour Interpolation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Fast, but produces "pixelated" images. May however work better for images with
sharp edges mostly consisting of big one color regions (it doesn't blur the
result on upscaling).

Bicubic Interpolation
^^^^^^^^^^^^^^^^^^^^^

Works well as is on image upscaling. To get decent result on downscaling
low-pass filter (Gaussian blur) must be used on original image before actual
downscaling. To do this reasonably fast we could cheat a little: first resize
big images a little without the low-pass filter, then apply low-pass filter and
finally downscale it to desired size.

Dithering
~~~~~~~~~

Currently there are two dithering algorithms implemented. Both takes an RGB888
24bit image as input and are able to produce any RGB or Grayscale image.
This filters doesn't work 'in-place' as the result has different pixel type.

Floyd-Steinberg
^^^^^^^^^^^^^^^

Classical Floyd-Steinberg. Produces good results and is a little faster than
the Hilbert-Peano dithering.

The error is distributed to neighbor pixels as follows:

[width="10%"]
|===================
|      |   X  | 7/16
| 3/16 | 5/16 | 1/16
|===================

And is throwed away at the image borders.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterFloydSteinberg_RGB888(const GP_Context *src,
                                   GP_Context *dst,
                                   GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Renders Floyd Steinberg dithering directly into passed context. The
destination must be at least as large as source. 

If operation was aborted by a callback, non-zero is returned.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterFloydSteinberg_RGB888_Alloc(const GP_Context *src,
                                                 GP_PixelType pixel_type,
                                                 GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Returns pointer to allocated context of given pixel_type.

If malloc(2) has failed, or operation was aborted by a callback 'NULL' is
returned.

Hilbert-Peano
^^^^^^^^^^^^^

Hilbert-Peano space filling curve based dithering.
 
The error value is distributed around the Hilbert curve.

The result is a little more noisy, but doesn't create repeating patterns like
Floyd-Steinberg which looks generally better to human eye. On the other hand
edges tend to be less sharp.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

int GP_FilterHilbertPeano_RGB888(const GP_Context *src,
                                 GP_Context *dst,
                                 GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Renders Hilbert Peano dithering directly into passed context. The
destination must be at least as large as source. 

If operation was aborted by a callback, non-zero is returned.

[source,c]
-------------------------------------------------------------------------------
#include <GP_Filters.h>

GP_Context *GP_FilterHilbertPeano_RGB888_Alloc(const GP_Context *src,
                                               GP_PixelType pixel_type,
                                               GP_ProgressCallback *callback);
-------------------------------------------------------------------------------

Returns pointer to allocated context of given pixel_type.

If malloc(2) has failed, or operation was aborted by a callback 'NULL' is
returned.

Example Images
^^^^^^^^^^^^^^
All following images were generated using 'grinder'.
(Click for bigger size)

.Original Image; Floyd-Steinberg, Hilbert-Peano: 1-bit, 2-bit, 4-bit, 8-bit Grayscale; 1-bit, 2-bit, 3-bit (per channel) RGB
image:images/dither/lenna_small.png[
	"Original Image", 
	link="images/dither/lenna.png"]
image:images/dither/lenna_G1_FS_small.png[
	"1-bit Grayscale Floyd-Steinberg",
	link="images/dither/lenna_G1_FS.png"]
image:images/dither/lenna_G1_HP_small.png[
	"1-bit Grayscale Hilbert-Peano",
	link="images/dither/lenna_G1_HP.png"]
image:images/dither/lenna_G2_FS_small.png[
	"2-bit Grayscale Floyd-Steinberg",
	link="images/dither/lenna_G2_FS.png"]
image:images/dither/lenna_G2_HP_small.png[
	"2-bit Grayscale Hilbert-Peano",
	link="images/dither/lenna_G2_HP.png"]
image:images/dither/lenna_G4_FS_small.png[
	"4-bit Grayscale Floyd-Steinberg",
	link="images/dither/lenna_G4_FS.png"]
image:images/dither/lenna_G4_HP_small.png[
	"4-bit Grayscale Hilbert-Peano",
	link="images/dither/lenna_G4_HP.png"]
image:images/dither/lenna_G8_FS_small.png[
	"8-bit Grayscale Floyd-Steinberg",
	link="images/dither/lenna_G8_FS.png"]
image:images/dither/lenna_G8_HP_small.png[
	"7-bit Grayscale Hilbert-Peano",
	link="images/dither/lenna_G8_HP.png"]
image:images/dither/lenna_RGB111_FS_small.png[
	"1-bit RGB Floyd-Steinberg",
	link="images/dither/lenna_RGB111_FS.png"]
image:images/dither/lenna_RGB111_HP_small.png[
	"1-bit RGB Hilbert-Peano",
	link="images/dither/lenna_RGB111_HP.png"]
image:images/dither/lenna_RGB222_FS_small.png[
	"2-bit RGB Floyd-Steinberg",
	link="images/dither/lenna_RGB222_FS.png"]
image:images/dither/lenna_RGB222_HP_small.png[
	"2-bit RGB Hilbert-Peano",
	link="images/dither/lenna_RGB222_HP.png"]
image:images/dither/lenna_RGB333_FS_small.png[
	"3-bit RGB Floyd-Steinberg",
	link="images/dither/lenna_RGB333_FS.png"]
image:images/dither/lenna_RGB333_HP_small.png[
	"3-bit RGB Hilbert-Peano",
	link="images/dither/lenna_RGB333_HP.png"]

